<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RE9T</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://39.105.230.153:666/"/>
  <updated>2019-11-23T13:20:35.486Z</updated>
  <id>http://39.105.230.153:666/</id>
  
  <author>
    <name>re9t</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java与Python多线程入门</title>
    <link href="http://39.105.230.153:666/2019/11/23/1-md/"/>
    <id>http://39.105.230.153:666/2019/11/23/1-md/</id>
    <published>2019-11-23T13:20:35.487Z</published>
    <updated>2019-11-23T13:20:35.486Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为有需要，最近去学习了一下多线程，本来是只需要python的，结果又开了java课，没办法，只好顺带一起学了，做个对比也好。就拿素数为样例吧，本来应该是有一个多线程寻找开放的端口的，结果文件找不到了，也就换成求素数的，反正效果一样。</p><a id="more"></a><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>最近心态有些失衡，有几个月没写东西。不想写一些关于操作之类的文章，写些需要动脑筋的文章转移一下注意力。<br>一讲线程就会和进程联系起来。线程和进程的区别是什么？</p><ul><li>进程：是执行中一段程序，即一旦程序被载入到内存中并准备执行，它就是一个进程。进程是表示资源分配的的基本概念，又是调度运行的基本单位，是系统中的并发执行的单位。<br>线程：单个进程中执行中每个任务就是一个线程。线程是进程中执行运算的最小单位</li></ul><p>这讲起来有些抽象，一般来说一个单独的应用会被系统分配一个进程，而一个应用里面的某些方法则可以被当作经进程，我这里找到了一个关于线程进程的<a href="https://blog.csdn.net/zhangbijun1230/article/details/80474988" target="_blank" rel="noopener">比较有意思的故事</a>。<br>然后我们通过程序来加深理解。</p><p>再举一个简单的例子，按以往的思维，我写一个程序，要做到边听歌边写作业，以往只能做到要么先听歌，要么先写作业，而多线程就是，给听歌和写作业每个分配一个线程，然后同时运行(这个同时在计算机里面也是有先后的，只是太短，我们以为的同时)</p><h2 id="java多线程样例"><a href="#java多线程样例" class="headerlink" title="java多线程样例"></a>java多线程样例</h2><p>java多线程有两种方法，一个是就是继承Thread类，一个就是实现Runnable接口;区别呢也就是继承Thread类的只能继承一次，接口的可以实现多次。我把两个都写一下，顺别巩固一下接口相关知识。</p><hr><p><strong>为了方便起见，我写了一个工具类，用来作为素数求解工具</strong></p><h3 id="Prime工具类"><a href="#Prime工具类" class="headerlink" title="Prime工具类"></a>Prime工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prime</span> </span>&#123;</span><br><span class="line"><span class="comment">/*判断是否为素数*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num&lt;<span class="number">2</span>||(num!=<span class="number">2</span>&amp;&amp;num%<span class="number">2</span>==<span class="number">0</span>))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> s=(<span class="keyword">int</span>) Math.sqrt(num);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=s;i+=<span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(num%i==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*计算区间内素数*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">PrimeNum</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(isPrime(i))</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们先来做个对比的，求五千万以内的素数个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">50000000</span>;<span class="comment">//五千万</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取当前系统时间*/</span></span><br><span class="line"><span class="keyword">long</span> Time1 =  System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"素数 "</span>+Prime.PrimeNum(<span class="number">1</span>,count)+<span class="string">"个"</span>);</span><br><span class="line"><span class="keyword">long</span> Time2 =  System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"耗时"</span>+(Time2-Time1)/<span class="number">1000.0</span>+<span class="string">" s"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下:<br><img src="%5Cimage1.png" alt="image1"><br>这里花了30多秒计算出来五千万个素数，当然算法也比较优越，如果是最原始的算法，应该会有一个多小时，昨天我跑八百万都花了十几分钟，也可能是电脑太渣了。</p><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>关于继承Thread类的，其实也就是重写Thread类的run方法，run方法里面是线程start(开始)后运行的东西，我们在run函数里面写下我们想让执行的东西，每次start就会开启一个新线程执行run;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> test.Prime;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CulPrime</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CulPrime</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(start&gt;end) &#123;</span><br><span class="line">System.out.println(<span class="string">"不合理的区间"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.start=start;</span><br><span class="line"><span class="keyword">this</span>.end=end;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">"开始计算"</span>+start+<span class="string">","</span>+end);</span><br><span class="line"><span class="keyword">int</span> count = Prime.PrimeNum(start,end);</span><br><span class="line">num += count;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">"计算出 素数"</span>+count+<span class="string">"个"</span>);</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">"计算完成"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">50000000</span>;<span class="comment">//五千万</span></span><br><span class="line"></span><br><span class="line">Vector&lt;Thread&gt; threadvector=<span class="keyword">new</span> Vector&lt;Thread&gt;(); <span class="comment">//用于储存所有线程</span></span><br><span class="line"><span class="comment">/* 区间划分 为了方便，分成五段，每个线程计算一千万 */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;count;i+=count/<span class="number">5</span>) &#123;</span><br><span class="line">threadvector.add(<span class="keyword">new</span> CulPrime(i, i+count/<span class="number">5</span>-<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> Time3 =  System.currentTimeMillis();</span><br><span class="line"><span class="comment">/* 线程开始 */</span></span><br><span class="line"><span class="keyword">for</span>(Thread t: threadvector) &#123;</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 等待所有线程结束 */</span></span><br><span class="line"><span class="keyword">for</span>(Thread t: threadvector) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">t.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> Time4 =  System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"多线程计算: 素数 "</span>+num+<span class="string">"个"</span>);</span><br><span class="line">System.out.println(<span class="string">"多线程计算"</span>+<span class="string">"耗时"</span>+(Time4-Time3)/<span class="number">1000.0</span>+<span class="string">" s"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下:<br><img src="%5Cimage3.png" alt="image3"><br>差别很明显，计算结果一样，但是时间差了几倍。</p><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>首先，什么是接口，接口又是怎么实现的，我个人认为接口其实就是封装思维的最好体现，多个类之间通过接口访问，而不直接访问内部成员。就像是人和人之间，我们可以通过交流的方式获取别人的信息，而不是直接通过读取别人的脑子一样，这个三体人的样子我还记忆犹新。<br><a href="https://blog.csdn.net/aoxue018/article/details/81176783" target="_blank" rel="noopener">我这里找到了一个usb接口的样例</a>，讲道理接口更多像是一种协议，规定了访问方式，访问规则等待。<br>我们再来看看接口的实现方式,虽然最后时间结果应该是差不多的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> test.Prime;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 使用Runnable接口的步骤</span></span><br><span class="line"><span class="comment">    * 1.建立Runnable对象</span></span><br><span class="line"><span class="comment">    * 2.使用参数为Runnable对象的构造方法创建Thread实例</span></span><br><span class="line"><span class="comment">    * 3.调用start()启动线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CulPrime</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CulPrime</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(start&gt;end) &#123;</span><br><span class="line">System.out.println(<span class="string">"不合理的区间"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.start=start;</span><br><span class="line"><span class="keyword">this</span>.end=end;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">"开始计算"</span>+start+<span class="string">","</span>+end);</span><br><span class="line"><span class="keyword">int</span> count = Prime.PrimeNum(start,end);</span><br><span class="line">num += count;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">"计算出 素数"</span>+count+<span class="string">"个"</span>);</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">"计算完成"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">50000000</span>;<span class="comment">//五千万</span></span><br><span class="line"></span><br><span class="line">Vector&lt;Thread&gt; threadvector=<span class="keyword">new</span> Vector&lt;Thread&gt;(); <span class="comment">//用于储存所有线程</span></span><br><span class="line"><span class="comment">/* 区间划分 为了方便，分成五段，每个线程计算一千万 */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;count;i+=count/<span class="number">5</span>) &#123;</span><br><span class="line">threadvector.add(<span class="keyword">new</span> Thread(<span class="keyword">new</span> CulPrime(i, i+count/<span class="number">5</span>-<span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> Time3 =  System.currentTimeMillis();</span><br><span class="line"><span class="comment">/* 线程开始 */</span></span><br><span class="line"><span class="keyword">for</span>(Thread t: threadvector) &#123;</span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 等待所有线程结束 */</span></span><br><span class="line"><span class="keyword">for</span>(Thread t: threadvector) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">t.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> Time4 =  System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"多线程计算: 素数 "</span>+num+<span class="string">"个"</span>);</span><br><span class="line">System.out.println(<span class="string">"多线程计算"</span>+<span class="string">"耗时"</span>+(Time4-Time3)/<span class="number">1000.0</span>+<span class="string">" s"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下<br><img src="%5Cimage2.png" alt="image2"></p><p>显然，程序上只有一个调用的区别，而实际的计算速度，差别不大。接口的好处在于，可以有多个类实现接口，而继承只能是单个的。比如说我有学生类，老师类，人类等等，我可以每个类都实现接口，然后在一个程序里创造一个对象就可以，而不是每次都继承Thread类。</p><p>当然上面的例子里我开了5个线程，那么线程是不是越多越好？或者是有个什么限定？<br><img src="%5Cimage4.png" alt="image4"><br>很显然，我上面开了10个线程，明显比5个线程的快了一些，但是线程数目不是越多越好，对于单核cpu来说，线程只是合理的分配时间，把每个线程都划分一个时间段，以此加快速度，但是对于持久计算来说，先算和后算的区别不是太大；对于多核cpu来说，开的线程数量合适就可以使cpu的每个核都分配一个线程，这样运算速度自然提升。</p><h2 id="python多线程样例"><a href="#python多线程样例" class="headerlink" title="python多线程样例"></a>python多线程样例</h2><p>Python中使用线程有两种方式：函数或者用类来包装线程对象，简单来说就是，我的线程运行的要么是函数，要么是对象</p><hr><p>Python官方提供了两个线程包thread(python3改为_thread))和threading,当然thread的功能还是比较简陋的，所以我这里只拿threading做例子，毕竟人还是要与时俱进。</p><h3 id="函数式线程"><a href="#函数式线程" class="headerlink" title="函数式线程"></a>函数式线程</h3><p>实际上就是我有几个函数，然后每个函数分配线程而已。同样拿求素数为例子吧,老规矩，先来一个工具类Prime，因为python是解释型语言的原因，我们把计算数据范围调小.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prime</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod # 静态方法声明</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPrime</span><span class="params">(num)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">2</span> <span class="keyword">or</span> (num &gt; <span class="number">2</span> <span class="keyword">and</span> num % <span class="number">2</span> == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        n = int(math.sqrt(num))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n + <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> num % i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line"><span class="comment"># 该函数用于多线程测试</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrimeNum</span><span class="params">(ThreadName, start, end)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;ThreadName&#125;</span>开始计算<span class="subst">&#123;start&#125;</span>到<span class="subst">&#123;end&#125;</span>区间'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end + <span class="number">1</span>, <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> Prime.isPrime(i):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        print(<span class="string">'&#123;0&#125;计算完成'</span>.format(ThreadName))</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line"><span class="comment"># 该函数用于单线程测试</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrimeNum</span><span class="params">(start, end)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        print(<span class="string">f'开始计算<span class="subst">&#123;start&#125;</span>到<span class="subst">&#123;end&#125;</span>区间'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end + <span class="number">1</span>, <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> Prime.isPrime(i):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        print(<span class="string">'计算完成 素数个数为&#123;0&#125;'</span>.format(count))</span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><p>然后我们先测试一下单线程状态下的计算速度和时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    step = <span class="number">1000000</span> <span class="comment"># 一百万</span></span><br><span class="line">    StartTime = time.time()</span><br><span class="line">    PrimeNum(<span class="number">1</span>,<span class="number">1</span>*step)</span><br><span class="line">    EndTime = time.time()</span><br><span class="line">    print(<span class="string">"耗时: "</span>, EndTime - StartTime, <span class="string">"s"</span>)</span><br></pre></td></tr></table></figure><p><img src="./image5.png" alt="image5"><br>然后就是多线程下的计算.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    step = <span class="number">200000</span> <span class="comment"># 二十万</span></span><br><span class="line">    StartTime = time.time()</span><br><span class="line">    count = [<span class="number">1</span>, step + <span class="number">1</span>, <span class="number">2</span> * step + <span class="number">1</span>, <span class="number">3</span> * step + <span class="number">1</span>, <span class="number">4</span> * step + <span class="number">1</span>]  <span class="comment"># 一百万</span></span><br><span class="line">    threads = []</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> count:</span><br><span class="line">        threads.append(threading.Thread(args=[<span class="string">"Thread-"</span> + str(j), i, i + step - <span class="number">1</span>, ], target=Prime.PrimeNum))</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        StartTime = time.time()</span><br><span class="line">        <span class="comment"># 开始所有进程</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">            t.start()</span><br><span class="line">        <span class="comment"># 等待所有进程结束</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">            t.join()</span><br><span class="line">        EndTime = time.time()</span><br><span class="line">        print(<span class="string">"耗时: "</span>, EndTime - StartTime, <span class="string">"s"</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"Error: 无法启动线程"</span>, e)</span><br><span class="line">    EndTime = time.time()</span><br><span class="line">    print(<span class="string">"耗时: "</span>, EndTime - StartTime, <span class="string">"s"</span>)</span><br></pre></td></tr></table></figure><p><img src="./image6.png" alt="image6"></p><h3 id="类继承Thread类实现多线程"><a href="#类继承Thread类实现多线程" class="headerlink" title="类继承Thread类实现多线程"></a>类继承Thread类实现多线程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myThread</span> <span class="params">(threading.Thread)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">self.name=name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 线程主体</span></span><br><span class="line">print_name(self.name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_name</span><span class="params">(name)</span>:</span></span><br><span class="line">print(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新线程</span></span><br><span class="line">thread1 = myThread(<span class="string">"Thread-1"</span>)</span><br><span class="line">thread2 = myThread(<span class="string">"Thread-2"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启新线程</span></span><br><span class="line">thread1.start()</span><br><span class="line">thread2.start()</span><br><span class="line">thread1.join()</span><br><span class="line">thread2.join()</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"退出主线程"</span>)</span><br></pre></td></tr></table></figure><p>这里我只给一个模板，实际上继承之后只要像Java那样实现run方法就行了。</p><h3 id="python多线程总结"><a href="#python多线程总结" class="headerlink" title="python多线程总结"></a>python多线程总结</h3><p>很显然python利用计算素数的效率慢很多，而且多线程并不比单线程计算要快。原因有俩个，一个是python是解释型语言，运行效率比编译型语言慢很多。另一个就是python并不适合高并发、多线程程序的编写<br>。</p><p>一般来说我们写的python多线程都是单核多线程，也就是说线程与线程之间都是交替执行的,只是速度很快。这不是意味我们并不能用python写多核并发，实际上python是可以利用c/c++<br>实现多核并发的。<br><strong>参考</strong>:    <a href="https://blog.csdn.net/Android_xue/article/details/85039275" target="_blank" rel="noopener">python的优势和劣势</a></p><h2 id="多线程优化的原理"><a href="#多线程优化的原理" class="headerlink" title="多线程优化的原理"></a>多线程优化的原理</h2><p>线程的应用主要是并发和并行。</p><ul><li>并发(concurrency)：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行，避免阻塞和更有效利用资源。<strong>典型的例子有：在长时间工作的程序中使用工作线程避免界面失去响应。在网络下载程序中，使用多个线程提高对网络的使用效率，更快下载文件。</strong></li><li>并行(parallel)：指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。</li></ul><p>并发可以用在单核和多核处理器上，并行只能在多核处理器上。在我举的计算素数例子里面，如果我的电脑是单核的，多线程计算的速度可能并不会有优化，</p><p>对于单处理器系统，操作系统会轮流调度每个线程执行一小段时间，然后切换另一个线程，在切换的时候，保存当前线程使用的寄存器上下文和堆栈，并且在下次调度的时候恢复。这样线程中的程序感觉不到自己被中断过。对于多处理器系统，操作系统会将不同的线程调度给多个处理器，让它们并行执行。<br><strong>以下为我复习计组总结的，如有偏差还望纠正</strong><br>我们知道，程序运行在计算机里面实际上是下面这个过程<br> <figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--&gt; 程序数据存入主存</span><br><span class="line">--&gt; CPU从主存中取指令</span><br><span class="line">--&gt; CPU执行指令之间读取数据 </span><br><span class="line">--&gt; CPU写回运算结果</span><br><span class="line">--&gt; 输出设备输出结果</span><br></pre></td></tr></table></figure></p><ol><li><p>主存读写速度和cpu运算速度是不一致的，一般来说CPU运算速度会比主存读取速度快很多，而慢速的主存则会将快速的CPU速度降下来。</p></li><li><p>一台计算机中最核心的组件是 CPU、内存、以及 I/O 设备，这是冯罗伊曼体系结构决定的。三者速度依次减小。</p></li><li><p>程序的任务主要分两种类型，一种是I/O密集型（读写型），一种是CPU密集型（运算型）。注意：<strong>这个是相对概念</strong>。</p><p>程序的运行一般都是有顺序的，像一个队列一样。假设我们有两个任务，一个大量运算，一个UI显示，很显然，如果我们在执行任务1的时候，UI会卡住。所以我们的用户体验就会贼差，这时候就是并发的优势，我执行一段计算后再执行UI，两者交替执行，因为这个交替的速度很快，所以在用户看来，是同时执行的。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;因为有需要，最近去学习了一下多线程，本来是只需要python的，结果又开了java课，没办法，只好顺带一起学了，做个对比也好。就拿素数为样例吧，本来应该是有一个多线程寻找开放的端口的，结果文件找不到了，也就换成求素数的，反正效果一样。&lt;/p&gt;
    
    </summary>
    
    
      <category term="多线程" scheme="http://39.105.230.153:666/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="http://39.105.230.153:666/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://39.105.230.153:666/tags/Java/"/>
    
      <category term="Python" scheme="http://39.105.230.153:666/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>面向对象和面向过程的总结</title>
    <link href="http://39.105.230.153:666/2019/09/29/7-md/"/>
    <id>http://39.105.230.153:666/2019/09/29/7-md/</id>
    <published>2019-09-29T03:24:40.000Z</published>
    <updated>2019-11-09T14:29:16.896Z</updated>
    
    <content type="html"><![CDATA[<p>学了这么久的编程语言，也来总结一下自己关于面向对象和面向过程的一些思考。</p><a id="more"></a><p>就以翁恺老师讲的自动售货机为例</p><h3 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h3><p>对于面向过程的程序设计来说，他所考虑的是完成一个事情的具体步骤，比如我第一步做什么，第二步做什么，然后直到完成这个事情为止，当然这有点像那个算法实施的样子。</p><p>以自动售货机为例的话，那么我就应该考虑的是这中间有什么过程，我认为的顺序应该是，初始化，使用，关闭售货机。当然中间的使用又可以细化成若干的步骤。</p><ul><li>面向过程一般采取自顶而下的设计步骤，以函数式编程为主。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    ....   <span class="comment">//售货机的一些基本数据</span></span><br><span class="line"></span><br><span class="line">    init(data);<span class="comment">//初始化售货机</span></span><br><span class="line">    uses(data);<span class="comment">//使用售货机</span></span><br><span class="line">    close(data);<span class="comment">//关闭售货机</span></span><br><span class="line"></span><br><span class="line">    ....  <span class="comment">//结尾工作等等</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uses</span><span class="params">(Vending_machine data)</span></span>&#123;</span><br><span class="line">    ..... <span class="comment">//若干步骤</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>与面向过程不同，面向对象可以说是暂时跳出了步骤的圈子，它需要的是观察这个事情完成的过程中出现的各种事物，以及抽象出<strong>事物的属性及操作方法</strong>。</p><p>在自动售货机的例子里，出现了三个或者更多的事物，比如<strong>人</strong>、<strong>售货机</strong>以及<strong>商品</strong>等等。</p><ul><li><p>把这个抽象出来的<strong>事物属性及其操作方法</strong>统合起来叫做<strong>类</strong>。然后把类<strong>实例化</strong>后的东西叫做<strong>对象</strong>。</p></li><li><p>面向对象的编程在抽象出类后，往往要考虑类与外界的接口，比如说外界怎么访问这个类，这个类怎么操作外部等等。</p></li><li><p>注意：类里面的属性一般对外私有，尽管可以公有，但是不推荐</p></li></ul><p>以java、python和c++分别写一个代码为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thing1</span></span>&#123;</span><br><span class="line">    <span class="comment">//基础私有数据</span></span><br><span class="line">    <span class="keyword">private</span> Data data1;</span><br><span class="line">    <span class="keyword">private</span> Date data2;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    Ting1(Data d1,Data d2)&#123;&#125;</span><br><span class="line">    <span class="comment">//数据操作方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operat1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thing1</span>:</span></span><br><span class="line">    <span class="comment">#基础私有数据</span></span><br><span class="line">    __data1=...</span><br><span class="line">    __data2=...</span><br><span class="line">    <span class="comment">#操作方法等等</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">operate1</span><span class="params">()</span>:</span></span><br><span class="line">        ....</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thing1</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//基础私有数据</span></span><br><span class="line">    Data data1;</span><br><span class="line">    Data data2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//操作方法</span></span><br><span class="line">    Thing1();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operat1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当类定义之后，就需要实例化了。以自动售货机的例子来说</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//类实例化为对象</span></span><br><span class="line">        People p=<span class="keyword">new</span> People();<span class="comment">//人</span></span><br><span class="line">        VendMach vm=<span class="keyword">new</span> VendMach();<span class="comment">//售货机</span></span><br><span class="line">        Thing1 t1=<span class="keyword">new</span> Thing1();<span class="comment">//商品</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//售卖过程</span></span><br><span class="line">        vm.add(t1);<span class="comment">//售卖机添加商品t1</span></span><br><span class="line">        vm.operat(p.operat());<span class="comment">//人购买商品的信息发给售货机进行操作</span></span><br><span class="line">        .... </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大体上便是如此。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>面向过程和面向对象并不是分开的。但是侧重点都不一样。<br>面向过程侧重于具体的步骤和实现方法。而面向对象则侧重于数据。</p><ul><li>在c++里面 class和struct的差别就在于struct应该只有数据，而class还要包含数据的操作方法。（ps：貌似在c++里strcut也可以定义操作方法的，主要区别是strcut定义的数据默认是共有的，而class默认私有，当然为了和c的strcut区分，所以并不推荐使用struct定义方法）。</li><li>优缺点方面，面向过程的性能会好一些，所以在算法竞赛中一般都是使用c++面向的面向过程。但是对于大型程序来说，显然步骤是极多的，使用面向过程并不容易维护。而面向对象，则相反，类调用的时候实例化会有大开销。但是易于维护，复用，和扩展。毕竟从一个类里找错误和从一堆函数里面找错误的难度，可想而知哈</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学了这么久的编程语言，也来总结一下自己关于面向对象和面向过程的一些思考。&lt;/p&gt;
    
    </summary>
    
    
      <category term="一些没什么用的研究" scheme="http://39.105.230.153:666/categories/%E4%B8%80%E4%BA%9B%E6%B2%A1%E4%BB%80%E4%B9%88%E7%94%A8%E7%9A%84%E7%A0%94%E7%A9%B6/"/>
    
    
      <category term="python" scheme="http://39.105.230.153:666/tags/python/"/>
    
      <category term="c++" scheme="http://39.105.230.153:666/tags/c/"/>
    
      <category term="java" scheme="http://39.105.230.153:666/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>hexo的next主题使用总结</title>
    <link href="http://39.105.230.153:666/2019/09/29/2-md/"/>
    <id>http://39.105.230.153:666/2019/09/29/2-md/</id>
    <published>2019-09-28T16:33:37.000Z</published>
    <updated>2019-11-09T14:25:57.928Z</updated>
    
    <content type="html"><![CDATA[<ul><li>重新更换NEXT主题的使用总结<a id="more"></a></li><li>搭了几次博客了，一是服务器的问题，二是主题的原因。找了这么久终于找到了一个比较满意的主题-<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NEXT</a>。</li></ul><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>在自己的博客的根目录下载，使用如下目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>然后修改使用主题就可以了</p><p><a href="https://www.jianshu.com/p/efbeddc5eb19" target="_blank" rel="noopener">本文参考</a></p><h3 id="数据统计-不算子"><a href="#数据统计-不算子" class="headerlink" title="数据统计 不算子"></a>数据统计 不算子</h3><ul><li>next 已经集成了<a href="http://ibruce.info/" target="_blank" rel="noopener">不算子</a><br>只要在主题配置文件里面修改 busuanzi_count的enable为true即可<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="comment"># count values only if the other configs are false</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># custom uv span for the whole site</span></span><br><span class="line"><span class="attr">  site_uv:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  site_uv_header:</span> <span class="string">本站访客数</span></span><br><span class="line"><span class="attr">  site_uv_footer:</span> <span class="string">人次</span></span><br><span class="line">  <span class="comment"># custom pv span for the whole site</span></span><br><span class="line"><span class="attr">  site_pv:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  site_pv_header:</span> <span class="string">本站总访问量</span></span><br><span class="line"><span class="attr">  site_pv_footer:</span> <span class="string">次</span></span><br><span class="line">  <span class="comment"># custom pv span for one page only</span></span><br><span class="line"><span class="attr">  page_pv:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  page_pv_header:</span> <span class="string">本文总阅读量</span></span><br><span class="line"><span class="attr">  page_pv_footer:</span> <span class="string">次</span></span><br></pre></td></tr></table></figure></li></ul><p>当然要注意的是不算子的官网域名已经迁徙了，所以我们还需要修改busuanzi相应的配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim themes/next/layout/_third-party/analytics/busuanzi-counter.swig</span><br></pre></td></tr></table></figure><p>将里面的样式按照 <a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">不算子官网</a> 进行修改 即可</p><h3 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a>本地搜索</h3><p>此部分节选自<a href="https://www.jianshu.com/p/efbeddc5eb19" target="_blank" rel="noopener"></a>,如有侵权，请联系本人删除。</p><ul><li><p>在站点根目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li><li><p>然后修改站点配置文件，添加以下内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Search</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">search.xml</span></span><br><span class="line"><span class="attr">  field:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">  format:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">  limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure></li><li><p>然后修改主题配置文件，修改local_search中enable为true 即可</p></li></ul><h3 id="区域扩充"><a href="#区域扩充" class="headerlink" title="区域扩充"></a>区域扩充</h3><p>自带的Pisces样式虽然也不错，但是两边留白太多，并不是太好看。<br>可以修改内容区域的宽度。</p><ul><li>主题的 source/css/_variables/custom.styl 文件是next留给我们的自由配置的区域。官网的常见问题区有修改方法<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$main-desktop                   = 65%</span><br><span class="line">$content-desktop                = 75%</span><br></pre></td></tr></table></figure></li></ul><p>效果如我的博客。</p><h3 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h3><p><a href="http://theme-next.iissnan.com" target="_blank" rel="noopener">next使用文档</a><br><a href="https://www.jianshu.com/p/efbeddc5eb19" target="_blank" rel="noopener">迟道的博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;重新更换NEXT主题的使用总结
    
    </summary>
    
    
      <category term="杂七杂八的经验" scheme="http://39.105.230.153:666/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="hexo" scheme="http://39.105.230.153:666/tags/hexo/"/>
    
      <category term="next" scheme="http://39.105.230.153:666/tags/next/"/>
    
  </entry>
  
  <entry>
    <title>如何恢复静态hexo</title>
    <link href="http://39.105.230.153:666/2019/05/11/3-md/"/>
    <id>http://39.105.230.153:666/2019/05/11/3-md/</id>
    <published>2019-05-11T13:12:24.000Z</published>
    <updated>2019-11-09T14:26:21.787Z</updated>
    
    <content type="html"><![CDATA[<p>如何保存并且恢复静态hexo</p><a id="more"></a><h3 id="如何将本地hexo备份上github"><a href="#如何将本地hexo备份上github" class="headerlink" title="如何将本地hexo备份上github"></a>如何将本地hexo备份上github</h3><ul><li>前提：已经配置密匙且上传过hexo静态页面</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">git</span> <span class="string">clone</span> <span class="string">"远程仓库地址"</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>先将远程仓库克隆到本地，</li><li>然后进入clone的目录，打开git bash</li></ul></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">git</span> <span class="string">checkout</span> <span class="bullet">-b</span> <span class="string">hexo</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>创建并切换成hexo目录</li><li>然后将本地博客内的东西全部复制到该目录中</li><li>然后删除theme目录下的所有.git文件</li></ul></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">git</span> <span class="string">add</span> <span class="bullet">--all</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>该命令将所有文件加入缓存区</li></ul></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">git</span> <span class="string">commit</span> <span class="string">"源代码"</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>该命令将文件添加 自述内容</li></ul></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">git</span> <span class="string">push</span> <span class="string">origin</span> <span class="string">hexo</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>推送至远程仓库</li></ul></blockquote><h3 id="如何重新恢复本地博客"><a href="#如何重新恢复本地博客" class="headerlink" title="如何重新恢复本地博客"></a>如何重新恢复本地博客</h3><blockquote><ul><li>前提：已下载git和nodejs 和绑定密匙</li><li>先找一个文件用来准备存放需要克隆的文件</li><li>在该目录下打开git bash界面</li></ul></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">git</span> <span class="string">clone</span> <span class="bullet">-b</span> <span class="string">hexo</span> <span class="string">"远程仓库地址"</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>然后打开该文件，输入</li></ul></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">npm</span> <span class="string">install</span> <span class="string">hexo</span> <span class="bullet">--save</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>然后就完成了，接下来操作与正常hexo上传相似，<br>建议以后每次操作为（前提是如果在本地预览后没有问题，）。</li></ul></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">git</span> <span class="string">pull</span></span><br><span class="line"><span class="string">$</span> <span class="string">hexo</span> <span class="string">d</span> <span class="bullet">-g</span></span><br><span class="line"><span class="string">$</span> <span class="string">git</span> <span class="string">add</span> <span class="bullet">-all</span></span><br><span class="line"><span class="string">$</span> <span class="string">git</span> <span class="string">commit</span> <span class="bullet">-m</span> <span class="string">"代码自述"</span></span><br><span class="line"><span class="string">$</span> <span class="string">git</span> <span class="string">push</span> <span class="bullet">-u</span> <span class="string">origin</span> <span class="string">hexo</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何保存并且恢复静态hexo&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂七杂八的经验" scheme="http://39.105.230.153:666/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="hexo" scheme="http://39.105.230.153:666/tags/hexo/"/>
    
      <category term="github" scheme="http://39.105.230.153:666/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>如何配置github项目密匙</title>
    <link href="http://39.105.230.153:666/2019/05/11/9-md/"/>
    <id>http://39.105.230.153:666/2019/05/11/9-md/</id>
    <published>2019-05-11T13:12:24.000Z</published>
    <updated>2019-11-09T15:38:40.292Z</updated>
    
    <content type="html"><![CDATA[<ul><li>如何配置github项目密匙</li></ul><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>在此之前需要先要拥有一个自己的GitHub账号;<br>以及已经安装了git工具</p></blockquote><h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><blockquote><ul><li>首先找到自己的./ssh文件（有些可能找不到那也也是正常的，因为.ssh文件并不是初始化系统必虚的，该目录用于保存生成过的密匙匙，随便找个地方打开git bash，执行下面操作也有效）</li><li>右击.ssh文件夹打开git bash窗口，在打开的git bash窗口里，输入下面信息</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"youemail"</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>解释一下，youemail需要换成自己的注册GitHub账号的邮箱;然后在第一个提示句输入自己的github用户名_rsa ;<em>(可以换成其他的，这个用户名以后就是你的登陆句柄 )</em></li><li>这个时候.ssh文件就已经建立了，在c盘的用户下面可以找到它，然后在这个文件里面打开git bash窗口（已经到打开过了可以跳过）</li><li>然后继续在窗口内输入（一定要检查路径是不是在.ssh下，不然会很麻烦，ps-不堪回首）然后输入下面这句</li></ul></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">touch</span> <span class="string">coufig</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>然后打开coufig文件输入以下内容，注意不要在语句前加缩进和空格（ps-不堪回首）下面的one用于代替我的用户名</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># one</span><br><span class="line">Host one.github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/one_rsa</span><br><span class="line">User one</span><br></pre></td></tr></table></figure><blockquote><ul><li>注意不要改动 （详细参考<a href="https://www.cnblogs.com/xjnotxj/p/5845574.html?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">博客</a>)</li><li>前面弄完，并且已经保存后，执行下一步操作。</li></ul></blockquote><h3 id="添加公匙"><a href="#添加公匙" class="headerlink" title="添加公匙"></a>添加公匙</h3><blockquote><ul><li>打开自己的github账号，并且在设置里面的ssh里面添加ssh，密匙名字随便写，内容就要在.ssh文件里面找到自己建立的–比如我的是one_rsa.pub，将里面的内容复制到上面就行</li><li>然后就是最后一步，测试</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ssh</span> -T git@one.github.com</span><br></pre></td></tr></table></figure><blockquote><ul><li>注意，我上面的one仅是样例，可以更改，可以与多个github绑定，设置不同的句柄，每个新账号的添加步骤一致。</li></ul></blockquote><p>如果不知道.ssh路径在哪的 请参考大佬<a href="https://runindark.com/2019/03/23/My%20first%20blog/" target="_blank" rel="noopener">博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;如何配置github项目密匙&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="杂七杂八的经验" scheme="http://39.105.230.153:666/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="github" scheme="http://39.105.230.153:666/tags/github/"/>
    
      <category term="ssh" scheme="http://39.105.230.153:666/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>web新手题</title>
    <link href="http://39.105.230.153:666/2019/04/11/4-md/"/>
    <id>http://39.105.230.153:666/2019/04/11/4-md/</id>
    <published>2019-04-11T13:12:24.000Z</published>
    <updated>2019-11-09T15:31:26.636Z</updated>
    
    <content type="html"><![CDATA[<p>做了一些ctf新手题，于是觉得需要总结一波。</p><a id="more"></a><h3 id="view-source"><a href="#view-source" class="headerlink" title="view_source"></a>view_source</h3><blockquote><p>签到题，按f12查看源码，即可获得flag，当然也可以将源码下载下来再查看(ctrl+s)<br>为了练习python，我还是写了一个python代码</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment">#该函数用于获取flag，数据提交方式为get</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(url,p)</span>:</span></span><br><span class="line">    rsp = requests.get(url)</span><br><span class="line">    flag=re.findall(p,rsp.text)</span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://111.198.29.45:56606/"</span></span><br><span class="line">p = <span class="string">r'cyberpeace&#123;[0-9a-zA-Z]*&#125;'</span></span><br><span class="line">flag=get_flag(url,p)</span><br><span class="line">print(flag)</span><br></pre></td></tr></table></figure><h3 id="get-post"><a href="#get-post" class="headerlink" title="get_post"></a>get_post</h3><blockquote><p><a href="https://www.cnblogs.com/ranyonsue/p/5984001.html" target="_blank" rel="noopener">http协议详解</a>    <a href="http://www.w3school.com.cn/tags/html_ref_httpmethods.asp" target="_blank" rel="noopener">get和post的对比</a></p></blockquote><blockquote><p>http协议中有两种基本的请求方法<strong>get</strong>和<strong>post</strong><br>get适合较小的数据提交，post适合大量数据的提交，</p></blockquote><blockquote><p>对于做这个题，我们只需要了解get和post的提交方法就行</p><ul><li>网址?name=value 这种方式就可以将name的值提交上去，就像是百度搜索的时候，应该有一个 <strong>?wd=···</strong> 这个就是get提交方式。有一个缺陷就是get提交的数据在url都是可见的</li><li>post提交比较复杂，这里推荐一个火狐的插件hackbar，可以利用它进行post数据提交，方式也是name=value。</li></ul></blockquote><h3 id="robots"><a href="#robots" class="headerlink" title="robots"></a>robots</h3><blockquote><p><a href="https://baike.baidu.com/item/robots%E5%8D%8F%E8%AE%AE/2483797?fr=aladdin&fromid=9518761&fromtitle=robots.txt" target="_blank" rel="noopener">rotots协议</a></p></blockquote><blockquote><p>大多数网站都会使用robots协议,协议告诉搜索引擎什么可以被访问，什么不可以被访问。但其实也透露了很多信息，以前了解到这个知识的时候就在想，这玩意有了不就是此地无银三百两吗？</p></blockquote><blockquote><ul><li>实际操作就是直接访问robots.txt就可以了，比如这个题就是<a href="http://111.198.29.45:35952/robots.txt，然后就可以看见哪些不能访问(是指不能被搜索到，但是可以输入链接还是可以访问的)" target="_blank" rel="noopener">http://111.198.29.45:35952/robots.txt，然后就可以看见哪些不能访问(是指不能被搜索到，但是可以输入链接还是可以访问的)</a></li></ul></blockquote><h3 id="backup"><a href="#backup" class="headerlink" title="backup"></a>backup</h3><blockquote><p>基础知识部分，每次修改php时都会产生一个备份文件，会引起信息的泄露，这部分文件外界也可以访问,形式可能是以下几种，直接下载xia’l</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index.php→ index.php.bak</span><br><span class="line">index.php→ index.old</span><br><span class="line">index.php→ index.php.temp</span><br></pre></td></tr></table></figure><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><blockquote><p><a href="https://baike.baidu.com/item/cookie/1119" target="_blank" rel="noopener">cookie</a></p></blockquote><blockquote><p>cookie用来为网页端保存在本地的数据，有些用户的数据保存在cookie里，本地是可以查看的。（查看方法为在url左边的一个小图标，点击就可以查看里面的内容）</p></blockquote><h3 id="disabled-button"><a href="#disabled-button" class="headerlink" title="disabled_button"></a>disabled_button</h3><blockquote><p><a href="http://www.w3school.com.cn/tags/att_button_disabled.asp" target="_blank" rel="noopener">disabled属性</a></p></blockquote><blockquote><p>html里有个特殊的按钮，这个按钮只有样子，却不能按下，原因是button标签里面有个disabled属性。我们只要删掉这个属性，就可以按下去了。</p></blockquote><h3 id="simple-js"><a href="#simple-js" class="headerlink" title="simple_js"></a>simple_js</h3><blockquote><p>这个题貌似是考察js函数，打开源代码分析，可以知道，没有数据提交，就知道flag应该就藏在源代码里面，发现一个看似非常复杂的函数，将它化简之后就会发现，其实一点用都没有，还有一个非常长的16进制字符串。我们先将这个16进制数转换为字符串，方法有很多，我这里使用的他自己提供的这个复杂函数(先将下面的16进制数转为字符串，然后用这个字符串代替函数在的字符串，最后运行就可以得到flag值)</p></blockquote><h3 id="xff-referer"><a href="#xff-referer" class="headerlink" title="xff_referer"></a>xff_referer</h3><blockquote><p><a href="https://baike.baidu.com/item/X-Forwarded-For/3593639?fr=aladdin" target="_blank" rel="noopener">xff</a>和<a href="https://baike.baidu.com/item/HTTP_REFERER/5358396" target="_blank" rel="noopener">refere</a></p></blockquote><blockquote><p>简单来说，X-Forwarded-For（xff）就是用来伪造ip信息的，题目所要求的ip地址来源可以通过修改xff来进行修改，referer是告诉服务器从哪个地方过来的</p></blockquote><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><blockquote><ol><li>在这里推荐一个工具burp-suite，这个工具可以很方便的进行各种网页操作，比如拦截信息， 修改报头，爆破等等。</li><li>第二个方法为写python代码。代码如下</li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#获取响应信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_rsp</span><span class="params">(url,head)</span>:</span></span><br><span class="line">    req = requests.get(url,headers=head )</span><br><span class="line">    req.encoding = <span class="string">'utf-8'</span></span><br><span class="line">    <span class="keyword">return</span> req</span><br><span class="line"><span class="comment">#设置报头</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_head</span><span class="params">(send_ip,send_referer)</span>:</span></span><br><span class="line">    head = &#123;&#125;</span><br><span class="line">    head[<span class="string">'X-Forwarded-For'</span>] = send_ip</span><br><span class="line">    head[<span class="string">'Referer'</span>] = send_referer </span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">url = input(<span class="string">"请输入url:  "</span>)</span><br><span class="line">send_ip = input(<span class="string">"请输入xff:  "</span>)</span><br><span class="line">send_referer = input(<span class="string">"请输入referer:  "</span>)</span><br><span class="line">send_head = set_head(send_ip,send_referer)</span><br><span class="line">print(<span class="string">"定制报头\n"</span>)</span><br><span class="line">print(send_head)</span><br><span class="line">rsp = get_rsp(url,send_head)</span><br><span class="line">print(<span class="string">"响应报头"</span>)</span><br><span class="line">print(rsp.headers)</span><br><span class="line">print(<span class="string">"响应内容"</span>)</span><br><span class="line">print(rsp.text )</span><br></pre></td></tr></table></figure><h3 id="weak-auth"><a href="#weak-auth" class="headerlink" title="weak_auth"></a>weak_auth</h3><blockquote><p>我们先随手输入一个账号密码，然后就可以看到提示为admin登陆，于是用户名便为admin,剩下的就为暴力破解，这里我使用的burp进行的破解，网上找了一个常用密码集，然后用这个密码集进行破解，很简单就弄出来密码.</p></blockquote><h3 id="webshell"><a href="#webshell" class="headerlink" title="webshell"></a>webshell</h3><blockquote><p><a href="https://baike.baidu.com/item/%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/1845646" target="_blank" rel="noopener">一句话木马</a></p></blockquote><blockquote><p>关于php的一句话木马 <strong>* <?php @eval($_POST[value]);?> *</strong> </p><ul><li>value的值可以直接对底层进行更改 便可以得到webshell，然后剩下的操作就和服务器上的操作一样，用post提交value的值就可以了</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell=system(&quot;ls&quot;);</span><br><span class="line">shell=system(&quot;cat flag.txt&quot;);</span><br></pre></td></tr></table></figure><h3 id="command-execution"><a href="#command-execution" class="headerlink" title="command_execution"></a>command_execution</h3><blockquote><p>和webshell一样的操作，由于这里不是php代码，可以看见这个直接使用命令，这里介绍一下<a href="https://blog.csdn.net/hetoto/article/details/84101745" target="_blank" rel="noopener">find命令</a>,此外分号;可以在一行执行多个命令操作</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;find -name flag.* </span><br><span class="line">cat 文件名</span><br></pre></td></tr></table></figure><h3 id="simple-php"><a href="#simple-php" class="headerlink" title="simple_php"></a>simple_php</h3><blockquote><p>这里主要是考察php知识，=为赋值，==只检查内容，===内容和类型都会检查，所以第一个判断语句只需要a=’0’即可，第二个中is_numeric($b)检查b是否为纯数字，第三个又需要$b比1234大，所以1235a便可</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做了一些ctf新手题，于是觉得需要总结一波。&lt;/p&gt;
    
    </summary>
    
    
      <category term="这是什么鬼题" scheme="http://39.105.230.153:666/categories/%E8%BF%99%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC%E9%A2%98/"/>
    
    
      <category term="web" scheme="http://39.105.230.153:666/tags/web/"/>
    
      <category term="python" scheme="http://39.105.230.153:666/tags/python/"/>
    
      <category term="php" scheme="http://39.105.230.153:666/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>用github展示自己的网页</title>
    <link href="http://39.105.230.153:666/2019/04/11/5-md/"/>
    <id>http://39.105.230.153:666/2019/04/11/5-md/</id>
    <published>2019-04-11T13:12:24.000Z</published>
    <updated>2019-11-23T14:52:42.640Z</updated>
    
    <content type="html"><![CDATA[<p>将自己制作的网页分享给别人看，又不能直接给对方发源码，所以通过github展示自己的网页是个不错的选择</p><a id="more"></a><p>首先我们打开自己的github<br><img src="./5.jpg" alt="image"><br>点击+号，新建仓库<br><img src="./5.2.jpg" alt="image"></p><blockquote><ul><li>名字可以随便取，但建议选项和我一样，以免意外，然后创建</li></ul></blockquote><p><img src="./5.3.jpg" alt="image"><br>然后上传自己的源码,源码主页面建议改成index.html<br><img src="./5.4.jpg" alt="image"><br>然后进入settings页面，找到github page部分，<br><img src="./5.5.jpg" alt="image"><br>然后选择主题，随便选一个即可，选择完成后，即完成。然后再次回到GitHub page页面，可以看见一个链接，该链接即为所自己展示的页面链接</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将自己制作的网页分享给别人看，又不能直接给对方发源码，所以通过github展示自己的网页是个不错的选择&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂七杂八的经验" scheme="http://39.105.230.153:666/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="github" scheme="http://39.105.230.153:666/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>GIT操作基础</title>
    <link href="http://39.105.230.153:666/2019/04/11/6-md/"/>
    <id>http://39.105.230.153:666/2019/04/11/6-md/</id>
    <published>2019-04-11T13:12:24.000Z</published>
    <updated>2019-11-09T14:28:35.909Z</updated>
    
    <content type="html"><![CDATA[<ul><li>关于GIT操作基础<a id="more"></a><h3 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h3></li></ul><blockquote><p>查看历史版本信息 git log如果想要查看简单信息须加上 –pretty=oneline</p></blockquote><hr><blockquote><p>回退版本 git reset –hard HEAD^     #为回退到当前版本的上一个版本.</p><ul><li>如果是 –hard HAED~n      #往上n个版本</li><li>还可以 –hard 版本号       #回退到该版本，可以是过去，或者将来 （仅仅是在本地回退，还需要推送上网页）</li></ul></blockquote><h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><blockquote><p><strong>git push -f -u origin master</strong> master可以换成其他分支，比如gh-pages<br>git pull    #更新，功能是取回远程主机某个分支的更新，再与本地的指定分支合并，它的完整格式稍稍有点复杂。</p></blockquote><blockquote><p>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</p><ul><li>git push   #推送，将本地文件推送至远程主机</li><li>git push -u origin hexo -f #强制推送hexo分支</li><li>git checkout -b hexo #新建并切换分支</li></ul></blockquote><hr><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><blockquote><ul><li>git init    #初始化仓库，本地</li><li>git add    #添加文件到本地仓库</li></ul></blockquote><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><blockquote><ul><li>git rm    #具体操作会有提示</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;关于GIT操作基础
    
    </summary>
    
    
      <category term="杂七杂八的经验" scheme="http://39.105.230.153:666/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="github" scheme="http://39.105.230.153:666/tags/github/"/>
    
      <category term="GIT" scheme="http://39.105.230.153:666/tags/GIT/"/>
    
  </entry>
  
  <entry>
    <title>关于搭建个人博客的心得</title>
    <link href="http://39.105.230.153:666/2019/04/11/8-md/"/>
    <id>http://39.105.230.153:666/2019/04/11/8-md/</id>
    <published>2019-04-11T13:12:24.000Z</published>
    <updated>2019-11-23T14:54:06.056Z</updated>
    
    <content type="html"><![CDATA[<p>&#8195;&#8195; 大概是大一下学期，在学长的介绍下认识了博客，也听他说了许许多多关于写博客的好处，又觉得是个很高端的东西。就想着自己也能有个自己的博客。于是就开始尝试搭建自己的个人博客网站。</p><a id="more"></a><h3 id="第一次尝试-WordPress"><a href="#第一次尝试-WordPress" class="headerlink" title="第一次尝试  WordPress"></a>第一次尝试  <strong>WordPress</strong></h3><p>&#8195;&#8195; 我第一次搭建博客使用的是WordPress+新浪云服务器。当时听说新浪云弄点小东西是免费的，图便宜的我就去了弄了，后来还是因为没钱续费而不了了之。</p><p>&#8195;&#8195; wordpress是一个比较简单的个人网站平台，搭建起来也比较简单。网上的教程一堆一堆的，我就简单的说一下步骤。</p><ul><li>前提是你要有一个自己的服务器，我演示的时候就以虚拟机，centos7作为服务器。</li><li>现在很多的安装教程都要求版本什么的。其实就一句话，只要你不是用的那种古董型的系统，一般都会满足条件，当然php环境还是要自己搭的，我就不进行赘述了。</li><li>有了服务器之后，就去下载<a href="https://cn.wordpress.org/download/" target="_blank" rel="noopener">wordpress官网</a>的压缩包,要注意的是必须将压缩包解压到你的网站根目录(一般来说Apache服务默认工作目录为/var/www/html/,这个就是你的网站根目录，如果Apache服务正常启动的话，在html文件夹的东西理论上是都可以被外界访问到的)</li><li>然后修改wp-config.php文件，设置好数据库的名称，用户名和密码。这里如果是个人使用的话，可以自己配置一个小型的mysql数据库，然后创建一个叫<strong>wordpress</strong>的数据库，这个就是数据库名称，然后在把用户名和密码设置好就差不多了。</li><li>最后一步就是打开浏览器，输入你的服务器域名,然后就会弹出安装界面，按照提示填写就可以了。(这里提一句，有些人弄不起域名和ip的关系，实际上域名是ip的一个映射，或者叫做ip的别名，但是这个东西不是你去做的，你需要去注册，我们常说的dns服务器做的工作实际上就是将域名转换成ip然后发给你，这个转换的规则实际上久域名解析时绑定的东西)</li></ul><p><a href="http://www.yzipi.com/13.htm" target="_blank" rel="noopener">详细安装过程</a></p><p>wordpress的搭建是很简单的，但是对个人的条件有点小小要求。</p><h3 id="第二次尝试-jekyll"><a href="#第二次尝试-jekyll" class="headerlink" title="第二次尝试  jekyll"></a>第二次尝试  <strong>jekyll</strong></h3><p>&#8195;&#8195;说起来这个东西真是让人头疼，我用这个东西的时候顺便还了解了github这个神奇的东西，实际上github可以作为一个托管仓库，仓库也就是字面上的意思，能够存储你的项目之类的，git还是一个比较好的版本管理工具，当然，github自己有个项目展示的功能，意思就是你可以自己做个网页放在上面，然后通过它就可以访问到实际效果。最主要的是，它是免费的O(∩_∩)O。</p><ul><li><p><a href="https://www.jekyll.com.cn/docs/installation/" target="_blank" rel="noopener">jekyll的搭建</a> , 因为有现成的哈，我就不赘述了，显得啰嗦。</p></li><li><p>这个东西的操作我现在也忘记的差不多了，依稀记得有个很方便的软件可以写博客，也不用写md文件，可以说是真正意义上的只有写作了。</p></li></ul><h3 id="现在-hexo"><a href="#现在-hexo" class="headerlink" title="现在 hexo"></a>现在 <strong>hexo</strong></h3><p>&#8195;&#8195;现在使用的是hexo的方式，hexo+github也可以用来着。hexo的方式可以说是真正的比较方便了。</p><ul><li><p>hexo的使用平台有很多，windows和linux都可以，mac貌似也可以。</p></li><li><p>虽然Windows可以，但是我还是推荐使用linux。原因有几个</p><ol><li>因为windows上的环境变量配置起来有点麻烦。</li><li>bash框还是使用的那种linux的风格</li><li>安装到windows上面一出现什么问题就会很麻烦。利用虚拟机搭建再上传到github会方便和安全很多。</li></ol></li><li><p>虚拟机以及镜像的安装，加上markdown的基本语法都应该是基本能够掌握的东西。</p></li><li><p>在linux系统里面，首先要安装git和nodejs，因为hexo是要通过nodejs的包管理器npm来进行安装的。这里我用ubuntu系统来进行举例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br><span class="line">$ sudo apt-get install nodejs</span><br><span class="line">$ sudo apt-get install npm</span><br><span class="line"><span class="comment"># nodejs有个比较方便的版本控制器—— n</span></span><br><span class="line">$ sudo npm install -g n</span><br><span class="line"><span class="comment"># 升级npm</span></span><br><span class="line">$ sudo npm install -g npm</span><br><span class="line"><span class="comment"># 替换npm为淘宝源镜像地址</span></span><br><span class="line">$ npm config <span class="built_in">set</span> registry http://registry.npm.taobao.org/</span><br><span class="line"><span class="comment"># 自此 准备工作完成</span></span><br></pre></td></tr></table></figure></li><li><p>安装hexo，并且测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装hexo </span></span><br><span class="line">$ sudo npm install -g hexo</span><br><span class="line"><span class="comment"># 使用hexo 创建并初始化 目录blog,然后打开它，期间不要断网</span></span><br><span class="line">$ hexo init blog &amp;&amp; <span class="built_in">cd</span> blog</span><br><span class="line"><span class="comment"># 完成之后 便已经有了一个默认的主题,使用hexo s启动服务</span></span><br><span class="line">$ hexo s</span><br><span class="line"><span class="comment"># 这时候会显示你的服务端口，默认是4000好像，可以在虚拟机外面 打开一个浏览器，然后输入虚拟机中的地址。便可以看到了。</span></span><br><span class="line"><span class="comment"># hexo g命令是生成静态页面，hexo s启动服务，hexo d是和git在一起的操作，意思是推送的意思。</span></span><br><span class="line">$ npm install hexo-deployer-git --save <span class="comment">#使用插件deploy-git</span></span><br></pre></td></tr></table></figure></li><li><p>推送hexo至github  </p><ol><li><p>找到你创建的仓库地址。配置站点根目录中的_config.yml文件，我只提几个关键的地方，在deploy的下面，配置成下面的这个样子</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">repository:</span> <span class="string">你的仓库地址</span></span><br><span class="line"><span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>注意：在你还不熟悉github的操作时，仓库名还是设置成，<strong>用户名.github.io</strong> 这个用户名就是你的用户名。</p></li><li><p>保存之后，在使用hexo d推送，实际上这里会报错的，因为我们并没有配置过github的项目密匙和账户信息，但是失败的时候会有提示的</p><img src="/2019/04/11/8-md/1.jpg"> <p>它让你设置git的user.email和user.name，按照它上面提示的就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.email <span class="string">"you@example.com"</span></span><br><span class="line">$ git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line"><span class="comment">#记得换成自己的注册github时的邮箱和用户名。</span></span><br><span class="line"><span class="comment"># 然后配置密匙和公匙。</span></span><br><span class="line">$ ssh-keygen -C <span class="string">'you@example.com'</span> -t rsa <span class="comment">#真实注册邮箱,接下来的提示一路回车便是。</span></span><br><span class="line">$ cat /root/.ssh/id_rsa.pub <span class="comment">#展示公有密匙。下面输出的一段字符全部复制下来，然后在gthub的仓库页面的设置栏，找到deploy key，创建新密匙，名字随便，然后把这段字符复制到里面，保存就OK。</span></span><br><span class="line">$ hexo d <span class="comment">#最后使用hexo d推送，如无报错表示推送成功，输入你的用户名.github.io便可以访问你的博客了。每次写完文章后记得重新生成静态页面，再重新推送。</span></span><br><span class="line">$ hexo d -g <span class="comment">#一步到位。</span></span><br></pre></td></tr></table></figure></li></ol><p>最后便可以在浏览器里面输入 <strong>用户名.github.io</strong> 就可以访问了。我的就是 <a href="https://qwq111.github.io/" target="_blank" rel="noopener">博客</a> 也可以观看一下。</p><p>ps: 配置密匙还不了解的，可以去看我的另一篇博文，如何配置github项目密匙。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;#8195;&amp;#8195; 大概是大一下学期，在学长的介绍下认识了博客，也听他说了许许多多关于写博客的好处，又觉得是个很高端的东西。就想着自己也能有个自己的博客。于是就开始尝试搭建自己的个人博客网站。&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂七杂八的经验" scheme="http://39.105.230.153:666/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="hexo" scheme="http://39.105.230.153:666/tags/hexo/"/>
    
      <category term="github" scheme="http://39.105.230.153:666/tags/github/"/>
    
      <category term="wordpress" scheme="http://39.105.230.153:666/tags/wordpress/"/>
    
      <category term="jekyll" scheme="http://39.105.230.153:666/tags/jekyll/"/>
    
  </entry>
  
</feed>
